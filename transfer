#!/bin/sh

#transfer: a backup helper for rsync 
#Copyright (C) 2012 Carlos Antelo

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.

VERSION="1.0beta7" # usefully for future incompatibilities

_print_help() {
  cat <<"  EOF" | cut -c5-
    This is a backup helper for rsync, it keeps things organized
    saves spaces, and helps with reports. Check the source, it's
    short, and can be very helpfull.

    USAGE:
    transfer [ [ -r REMOTE ] [ -l LOCAL ] [ -s SUBJECT ] 
        [ -p PREFIX ] [ -b BASE ] [ -d ] ] | [ -v ] | [ -h ] 

    OPTIONS:
      -r: remote hostname, default: localhost
      -l: local (backup server) hostname, default: localhost
      -s: subject, a grouping for backups, e.g. apache, 
          profiles, default: files
      -b: base destination, default: /var/backups/hosts.d/
          you can't use a relative path on this parameter
      -p: prefix for all paths
      -d: debug, set echo on the shell
      -v: version, print version number
      -h: help, print this message

    Be default backups are stored in /var/backups/hosts.d/, see 
    the -b option.

    transfer processes it's input from stdin, one folder/file per line, 
    if you need null terminated paths, use a wrapper on rsync and set the 
    -0 paramter youself, the same goes for excluding files.

    EXAMPLE:

    transfer -r example.net -s apache <<EOF
    /var/www/
    /srv/www/
    /etc/apache2/
    EOF

    ENVIRONMENT:

    RSYNC: name of the rsync executable or a wrapper
    UUIDGEN: name of the uuidgen executable
    DATEFMT: date format used for backup directories

    Changing default values:

    This are intended for making it more scripting friendly, 
    parameters take precedense.

    REMOTE: -r, LOCAL: -l, SUBJECT: -s, DEST_BASE: -b, PREFIX: -p
    
  EOF
}

_date() {
  # with the default format, directory entries will by 
  # shown ordered in the shell, with the oldest 
  # copies first
  date +"${DATEFMT-%Y%m%d%H%M%S}"
}

# defaults
REMOTE=${REMOTE-localhost}
LOCAL=${LOCAL-localhost}
SUBJECT=${SUBJECT-files}
DEST_BASE=${DEST_BASE-/var/backups/hosts.d/}
PREFIX=${PREFIX-/}

# paramter processing
while getopts r:l:s:b:p:dvh PARAM; do
  case $PARAM in
    r) REMOTE=$OPTARG;;
    l) LOCAL=$OPTARG;;
    s) SUBJECT=$OPTARG;;
    b) DEST_BASE=$OPTARG;;
    d) set -x;;
    v) echo "$VERSION"; exit 0;;
    p) PREFIX=$OPTARG;;
    h) _print_help; exit 0;;
   \?) _print_help; exit 1;;
  esac
done

# can't take relative paths on DEST_BASE
if [ "${DEST_BASE##/*}" ]; then
  echo You must use an absolute path if you change DEST_BASE
  exit 1
fi

# both of this are used as identifiers, 
SNAPSHOT_DATE=$(_date) # the readable part
UUID=$(${UUIDGEN-uuidgen}) # the unique part

# backups are grouped related to subject and origin
DEST=$DEST_BASE/$REMOTE/$SUBJECT

# copies are further separated in tmp, err, and ok
# for in progress, failed, and successfull respectively
mkdir -p "$DEST" || exit 1
cd "$DEST"
mkdir -p ok err "tmp/$SNAPSHOT_DATE/data.d/$PREFIX" || exit 1

# the real work will be done in this folder while
# it's still being transfered
cd "tmp/$SNAPSHOT_DATE/" || exit 1

# from here on make sure to end in err if we recive a signal
trap 'echo err > status' INT TERM

# all of the folowing plain files, along with the previous grouping
# are aids at safequeeping, restoring, creating report
# scripts, dashboards, etc

# script version
echo "$VERSION" > version 

# servers involved
echo "$LOCAL" > local  
echo "$REMOTE" > remote 

# service or dataset tag
echo "$SUBJECT" > subject 

# uuid tag
echo "$UUID" > uuid 

# uuid of the previous copy 
# (the source of the hardlinks)
cat "$DEST/ok/last/uuid" > previous 2>/dev/null

# start of transfers
_date > start 

# if a previous backup exists, hardlink any files that were 
# allready present on the previous backup
if [ -d "$DEST/ok/last/data.d/$PREFIX" ]; then
  PREVIOUS=--link-dest=$DEST/ok/last/data.d/$PREFIX
fi

# rsync will transfer each folder/file passed on standard input
# check the rsync manpage for details 
"${RSYNC-rsync}" --archive --recursive --protect-args \
  --log-file=rsync.log --itemize-changes --files-from=- \
  "$PREVIOUS" "$REMOTE:$PREFIX" "./data.d/$PREFIX" || echo err > status

# mark the end of them
_date > end 

# size of files
du -h ./data.d/ | sed s@./data.d/@./@ > size

# check if there ware any errors, sucessfull and 
# failed copies are quept on different folders
if [ -s status ]; then
  mv "$DEST/tmp/$SNAPSHOT_DATE" "$DEST/err"
else
  echo "ok" > status
  mv "$DEST/tmp/$SNAPSHOT_DATE" "$DEST/ok/"
  rm -f "$DEST/ok/last"
  ln -s "$DEST/ok/$SNAPSHOT_DATE" "$DEST/ok/last"
fi
