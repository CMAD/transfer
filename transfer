#!/bin/sh

#transfer: a backup helper for rsync 
#Copyright (C) 2012 Carlos Antelo

#This program is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.

VERSION="1.0beta8" # usefully for future incompatibilities

_print_help() {
  cat <<"  EOF" | cut -c5-
    This is a backup script around rsync, it pulls files from 
    a remote server in the local machine through ssh. 

    USAGE:
    transfer [ [ -r REMOTE ] [ -l LOCAL ] [ -s SUBJECT ] 
        [ -p PREFIX ] [ -b BASE ] [ -d ] ] | [ -v ] | [ -h ] 

    OPTIONS:
      -r: remote hostname, default: localhost
      -l: local hostname, default: localhost (for metadata only)
      -s: subject, a grouping for backups, e.g. apache, 
          default: files
      -b: base destination, default: /var/backups/hosts.d/
          you can't use a relative path with this parameter
      -p: prefix for all source paths
      -d: debug, set echo on the shell
      -v: version, print version number
      -h: help, print this message

    Be default backups are stored in /var/backups/hosts.d/

    Inside for every different remote, a folder will
    be kept.

    A subject parameter intended to specify either a service
    or otherwise know set of files further distinguishes the 
    contents.

    e.g. /var/backups/hosts.d/example.net/vhosts

    Inside this folder even further distinction is made, 3 
    different folders establish the status of the copies:

    tmp: meanwhile a copy is being made
    err: if the script is interrupted or the transmission fails
    ok: when the script finishes successfully

    The final distinction is the date the copy was run. 
    A symbolic link is present on the ok folder 
    pointing to the last copy.

    A copy holds various plain text files with info on
    when and how was the backup made, including the remote and 
    local hostnames, the start, and finish time, size of the
    archive, status, etc. 

    Finally along with the metadata the data.d folder holds the 
    actual files, keeping the full original path, file 
    permissions, etc.

    When possible the last ok copy of the same particular set of
    files is used for hardlinking, saving space.

    transfer takes input from stdin, one folder/file per line, 
    currently if you need null terminated paths, you can set a wrapper 
    around rsync, presetting the -0 parameter, the same goes for 
    excluding files.

    EXAMPLE:

    transfer -r example.net -s apache <<EOF
    /var/www/
    /srv/www/
    /etc/apache2/
    EOF

    ENVIRONMENT:

    RSYNC: name of the rsync executable or a wrapper
    UUIDGEN: name of the uuidgen executable
    DATEFMT: date format used for backup directories

    Changing default values:

    REMOTE: -r, LOCAL: -l, SUBJECT: -s, DEST_BASE: -b, PREFIX: -p

    Parameters take precedence.
    
  EOF
}

_date() {
  # with the default format, directory entries will by 
  # shown ordered in the shell, with the oldest 
  # copies first
  date +"${DATEFMT-%Y%m%d%H%M%S}"
}

# give the opportunity to override defaults via shell
# exports and parameters
{

REMOTE=${REMOTE-localhost}
LOCAL=${LOCAL-localhost}
SUBJECT=${SUBJECT-files}
DEST_BASE=${DEST_BASE-/var/backups/hosts.d/}
PREFIX=${PREFIX-/}

while getopts r:l:s:b:p:dvh PARAM; do
  case $PARAM in
    r) REMOTE=$OPTARG;;
    l) LOCAL=$OPTARG;;
    s) SUBJECT=$OPTARG;;
    b) DEST_BASE=$OPTARG;;
    d) set -x;;
    v) echo "$VERSION"; exit 0;;
    p) PREFIX=$OPTARG;;
    h) _print_help; exit 0;;
   \?) _print_help; exit 1;;
  esac
done

if [ "${DEST_BASE##/*}" ]; then
  echo You must use an absolute path for the base destination
  exit 1
fi

}

# date is used as the identifier of the backup and is 
# more readable
SNAPSHOT_DATE=$(_date) 
# uuid is most usefull as a tie-breaker, 
# when moving copies to another media, or along with other tools
UUID=$(${UUIDGEN-uuidgen})

# backups are organized in a per host, per service basis
DEST=$DEST_BASE/$REMOTE/$SUBJECT

# further separated by it's status and date
mkdir -p "$DEST/ok/../err/../tmp/$SNAPSHOT_DATE/data.d/$PREFIX"

# the copy will remain in tmp until the backup finishes
cd "$DEST/tmp/$SNAPSHOT_DATE" || exit 1

# make sure to fail clean
trap 'echo err > status' INT TERM

# save safe-keeping information 
echo "$VERSION" > version 
echo "$REMOTE"  > remote 
echo "$SUBJECT" > subject 
echo "$LOCAL"   > local  
echo "$UUID"    > uuid 

# the same files can just share the same inode,
if [ -d "$DEST/ok/last/data.d/$PREFIX" ]; then
  PREVIOUS=--link-dest=$DEST/ok/last/data.d/$PREFIX
  cat "$DEST/ok/last/uuid" > previous
fi

_date > start 

{
# read from standard input, directories are pulled instead 
# of pushed to the backup server. 

"${RSYNC-rsync}" --archive --recursive --protect-args \
  --log-file=rsync.log --itemize-changes --files-from=- \
  "$PREVIOUS" "$REMOTE:$PREFIX" "./data.d/$PREFIX"
} || echo err > status

_date > end 

# as backups won't change once run, storing the size
# of files saves time
du -h ./data.d/ | sed s@./data.d/@./@ > size

# sucessfull and failed copies are kept on 
# different folders
if [ -s status ]; then
  mv "$DEST/tmp/$SNAPSHOT_DATE" "$DEST/err"
else
  echo "ok" > status
  mv "$DEST/tmp/$SNAPSHOT_DATE" "$DEST/ok/"
  rm -f "$DEST/ok/last"
  ln -s "$DEST/ok/$SNAPSHOT_DATE" "$DEST/ok/last"
fi
